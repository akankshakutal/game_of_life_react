{"version":3,"sources":["util.js","serviceWorker.js","gameTable.js","index.js","gameOfLife.js"],"names":["getCartisianProduct","columnNeighbours","cartisianProduct","element","index","length","push","validateNeighbours","limits","some","topX","topY","bottomX","bottomY","remove","cell","getValidNeighbours","neighbourCandidates","removeGivenCell","allNeighbours","filter","isValidNeighbour","module","exports","getNeighbours","cellCoordinates","rowNeighbours","reduce","Boolean","window","location","hostname","match","Table","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","GameOfLife","bounds","topLeft","bottomRight","size","makeCellAlive","bind","assertThisInitialized","startGame","stopGame","nextGeneration","getNextGenerationCells","state","aliveCells","event","id","target","split","map","x","document","getElementById","style","backgroundColor","rowIndex","row","columnIndex","ids","react_default","a","createElement","onClick","key","table","createTableRow","_this2","timerId","setInterval","clearInterval","nextGen","forEach","join","background","removeCellColor","colorNextGenerationCells","setState","className","createTable","React","Component","ReactDOM","render","gameTable","navigator","serviceWorker","ready","then","registration","unregister","require","contains","list","e","extractLimits","getAllCoordinates","allCoordinates","column","verifyRules","numOfNeighbours","currGeneration","includes","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","coordinate","value","err","return"],"mappings":"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","file":"static/js/main.b9579521.chunk.js","sourcesContent":["const getCartisianProduct = function(columnNeighbours) {\n  return function(cartisianProduct, element) {\n    for (let index = 0; index < columnNeighbours.length; index++) {\n      cartisianProduct.push([element, columnNeighbours[index]]);\n    }\n    return cartisianProduct;\n  };\n};\n\nconst validateNeighbours = function(limits) {\n  return function(element) {\n    return !element.some(\n      element =>\n        (element < limits.topX && element < limits.topY) ||\n        (element > limits.bottomX && element > limits.bottomY)\n    );\n  };\n};\n\nconst remove = function(cell) {\n  return function(element) {\n    return !(element[0] == cell[0] && element[1] == cell[1]);\n  };\n};\n\nconst getValidNeighbours = function(cell, neighbourCandidates, limits) {\n  let removeGivenCell = remove(cell);\n  let allNeighbours = neighbourCandidates.filter(removeGivenCell);\n  let isValidNeighbour = validateNeighbours(limits);\n  return allNeighbours.filter(isValidNeighbour);\n};\n\nconst getNeighbours = function(cellCoordinates, limits) {\n  let rowNeighbours = [\n    cellCoordinates[0] - 1,\n    cellCoordinates[0],\n    cellCoordinates[0] + 1\n  ];\n  let columnNeighbours = [\n    cellCoordinates[1] - 1,\n    cellCoordinates[1],\n    cellCoordinates[1] + 1\n  ];\n  let cartisianProduct = getCartisianProduct(columnNeighbours);\n  let neighbourCandidates = rowNeighbours.reduce(cartisianProduct, []);\n  let neighbours = getValidNeighbours(\n    cellCoordinates,\n    neighbourCandidates,\n    limits\n  );\n  return neighbours;\n};\n\nmodule.exports = {\n  getCartisianProduct,\n  validateNeighbours,\n  remove,\n  getValidNeighbours,\n  getNeighbours\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport \"./index.css\";\nimport GameOfLife from \"./gameOfLife\";\n\nclass Table extends React.Component {\n  constructor(props) {\n    super(props);\n    this.GameOfLife = GameOfLife;\n    this.bounds = {\n      topLeft: [0, 0],\n      bottomRight: [this.props.size - 1, this.props.size - 1]\n    };\n    this.makeCellAlive = this.makeCellAlive.bind(this);\n    this.startGame = this.startGame.bind(this);\n    this.stopGame = this.stopGame.bind(this);\n    this.nextGeneration = this.GameOfLife.nextGeneration.bind(this);\n    this.getNextGenerationCells = this.getNextGenerationCells.bind(this);\n    this.state = { aliveCells: [] };\n  }\n\n  makeCellAlive(event) {\n    let id = event.target.id;\n    this.state.aliveCells.push(id.split(\"_\").map(x => +x));\n    let element = document.getElementById(id);\n    element.style.backgroundColor = \"black\";\n  }\n\n  createTableRow(rowIndex) {\n    let row = [];\n    for (let columnIndex = 0; columnIndex < this.props.size; columnIndex++) {\n      let ids = rowIndex + \"_\" + columnIndex;\n      row.push(<td onClick={this.makeCellAlive} id={ids} key={ids} />);\n    }\n    return row;\n  }\n\n  createTable() {\n    let table = [];\n    for (let rowIndex = 0; rowIndex < this.props.size; rowIndex++) {\n      let row = this.createTableRow(rowIndex);\n      table.push(<tr key={rowIndex}>{row}</tr>);\n    }\n    return <tbody id=\"table-body\">{table}</tbody>;\n  }\n\n  startGame() {\n    this.timerId = setInterval(() => {\n      this.getNextGenerationCells();\n    }, 100);\n  }\n\n  stopGame() {\n    clearInterval(this.timerId);\n  }\n\n  colorNextGenerationCells(nextGen) {\n    nextGen.forEach(cell => {\n      let id = cell.join(\"_\");\n      document.getElementById(id).style.background = \"black\";\n    });\n  }\n\n  removeCellColor() {\n    this.state.aliveCells.forEach(cell => {\n      let id = cell.join(\"_\");\n      document.getElementById(id).style.background = \"white\";\n    });\n  }\n\n  getNextGenerationCells() {\n    let nextGen = this.nextGeneration(this.state.aliveCells, this.bounds);\n    this.removeCellColor();\n    this.colorNextGenerationCells(nextGen);\n    this.setState(state => (state.aliveCells = nextGen));\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>Game of Life</h2>\n        <div className=\"table-view\">\n          <table id=\"table\">{this.createTable()}</table>\n        </div>\n        <div className=\"button-view\">\n          <button onClick={this.startGame}>Start</button>\n          <button onClick={this.stopGame}>Stop</button>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Table;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport Table from \"./gameTable\";\n\nReactDOM.render(<Table size={30} />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","const { getNeighbours } = require(\"./util.js\");\n\nconst nextGeneration = function(currGeneration, bounds) {\n  let limits = extractLimits(bounds);\n  let allCoordinates = getAllCoordinates(limits);\n  let includes = contains.bind(null, currGeneration);\n  let aliveCells = [];\n\n  for (let coordinate of allCoordinates) {\n    let neighbours = getNeighbours(coordinate, limits);\n    let numOfNeighbours = neighbours.filter(includes).length;\n    if (\n      (numOfNeighbours == 2 && contains(currGeneration, coordinate)) ||\n      verifyRules(numOfNeighbours) == 1\n    )\n      aliveCells.push(coordinate);\n  }\n  return aliveCells;\n};\n\nconst contains = (list, element) =>\n  list.some(e => e[0] === element[0] && e[1] === element[1]);\n\nconst extractLimits = function(bounds) {\n  return {\n    topX: bounds.topLeft[0],\n    topY: bounds.topLeft[1],\n    bottomX: bounds.bottomRight[0],\n    bottomY: bounds.bottomRight[1]\n  };\n};\n\nconst getAllCoordinates = function(limits) {\n  let allCoordinates = [];\n  for (let row = limits.topX; row <= limits.bottomX; row++) {\n    for (let column = limits.topY; column <= limits.bottomY; column++) {\n      allCoordinates.push([row, column]);\n    }\n  }\n  return allCoordinates;\n};\n\nconst verifyRules = function(numOfNeighbours) {\n  if (numOfNeighbours < 2 || numOfNeighbours > 3) {\n    return 0;\n  }\n  if (numOfNeighbours == 3) {\n    return 1;\n  }\n};\n\nmodule.exports = { nextGeneration };\n"],"sourceRoot":""}